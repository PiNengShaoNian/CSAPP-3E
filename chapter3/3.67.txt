A. 画出eval的栈帧,给出他在调用process前存储在栈上的值。
(%rsp)   --> x
8(%rsp)  --> y
16(%rsp) --> &z = 24(%rsp)
24(%rsp) --> z
64(%rsp) --> 用于返回结构体

B. eval调用process时传递了什么值
%rsp + 64

C. process参数是如何访问结构参数s的元素的？
process过程通过rsp寻址结构体参数s中的元素，并没有显式的参数传递。
在eval过程中，结构体s位于eval的栈帧中rsp+0的位置，
由于在call process指令执行时会将返回地址压栈(rsp的值减去了8字节)，
因此到了过程process中结构体参数s位于rsp+8的位置上。

D.process的代码是如何设置结构体r的字段的
在process过程中，参数结构体的起始位置为%rsp + 8
%rsp + 8   --> a[0] = x
%rsp + 16  --> a[1] = y 
%rsp + 24  --> *p   = &z = %rsp + 32
可以看到，process的汇编代码分别将%rsp + 8,%rsp + 16,%rsp + 24
里的值分别存储到了%rdi + 8,%rdi,%rdi + 16,也就是
r.u[0] = s.a[1]
r.u[1] = s.a[0]
r.q = *s.p

E. 完成eval的栈帧图，给出在从process返回后eval是如何访问结构体r的元素的？
(%rsp)   --> x
8(%rsp)  --> y
16(%rsp) --> &z = 24(%rsp)
24(%rsp) --> z
64(%rsp) --> r.u[0]
72(%rsp) --> r.u[1]
80(%rsp) --> r.q
调用process后回到eval中，process的返回值结构体r被放在了rsp+64开始的内存处，
因此只需要在这个地址的基础上加上偏移就可以访问到返回的结构体r的各个元素。

F. 就如何传递作为参数的结构以及如何返回作为函数结构的结构体，
你可以看出什么通用的原则？
结构体无论是作为函数参数还是作为返回值，都是通过内存传参，而不是通过寄存器。
作为函数参数时，在子过程中，通过rsp+偏移量访问结构体参数中的各个元素，
作为返回值时，才调用子过程时通过%rdi寄存器将返回值结构体在主过程中的
存放起始位置传给子过程。
