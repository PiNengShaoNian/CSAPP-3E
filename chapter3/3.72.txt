栈的字节对齐,实际是指栈顶指针必须是16字节的整数倍。栈对齐帮助尽量在尽可能少的
内存访问周期内读取数据，不对齐的堆栈指针可能导致严重的性能下降。
上文我们说到，即使数据没有对齐，我们的程序也是可以执行的，只是效率有点低而已，
但是某些型号的Intel和AMD处理器对于有实现多媒体操作的SSE指令，如果数据没有对齐
的话，就无法正确执行。这些指令对16字节内存进行操作，在SSE单元和内存之间传送
数据的指令要求内存地址必须是16的倍数。
因此，任何针对x86_64处理器的编译器和运行时系统都要求必须保证分配用来保存可能
会被SSE寄存器或写的数据结构的内存，都必须是16字节对其的，这就形成了一种标准：
  . 任何内存分配函数(alloca, malloc, calloc或realloc)生成的块起始地址都
    必须是16的倍数
  . 大多数函数的栈帧边界都必须是16直接的倍数
如上，在运行时栈中，不仅传递的参数和局部变量要满足字节对齐，我们栈指针(%rsp)
也必须是16的倍数

A. 第五行leaq计算得到8n + 30,然后andq将其向下舍入到最接近16的倍数；
   -16 = 0xFFFFF....FF0;

  (8n + 30) & 0xFFFFF....FF0
= 8n + 30 - (8n + 30) mod 16
当n为偶数时：
上式 = 8n + 30 - (16 * n / 2 + 30) mod 16
     = 8n + 30 - 30 mod 16
     = 8n + 16
当n为奇数时:
上式 = 8n + 30 - (16 * ((n + 1) / 2 - 1 / 2) + 30) mod 16
     = 8n + 30 - ((-8 + 30) mod 16)
     = 8n + 24
所以当n为偶数时s2 = s1 - (8n + 16),当n为奇数时s2 = s1 - (8n + 24)

B. p = (s2 + 15) % 0xFFFFF....FF0利用了`偏置`将s2向上舍入到最近的16的倍数

D. s2将8 * n的大小的空间的偏移量保留为最小的16的倍数，p以16字节的倍数对齐